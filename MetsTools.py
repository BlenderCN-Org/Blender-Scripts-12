# Operators in this script:

# Make Physics Bones
#	Sets up a somewhat iffy physics rig on a string of selected pose bones. (aka video game style physics) Careful when using this, it does a lot of stuff.

# Bake Auto Smooth
#	Edges that are sharp because of Auto Smooth are marked as sharp. Works on entire selection of objects.

# Create LightMap UVs
#	If an object has exactly 1 UV channel, this creates a 2nd one using Smart UV Unwrap. Works on entire selection of objects. You can tweak the settings of the projection. Great for quickly creating lightmaps for game engines that tend to be better than the ones generated by the engine on import.

# Clean Up Blend
#	Massively automatized house keeping stuff. Has dozens of checkboxes, each describe what it does, see those tooltips to learn more. Works on entire selection of objects, or globally. Always works on all materials and other node trees globally.



################################################
# Todo
#	UI
#		Replace the "Remove unused vertex groups" addon's button that I found a long time ago with my own one.
#	I'm not sure that my useless vertex group removal logic is correct right now - There are two separate calls to o.vertex_groups.remove(), when I think there should really only be one, and everything else should just be adding to safeVGroups.


# Add these:
#	CleanBioshockInfiniteImport
#		Alternatively, could have one CleanUpImport operator with various sources as options.
#	AutoSetupDirectXNormalMap - In the material editor, when a texture node is selected(expected that user will select normal map node) set datatype to non-color, create separateRGB, invert, combineRGB and normal map nodes, connect normal map node output to any BSDFs whose normal maps are currently unplugged.

# Make these:
#	Copy selected keyframes to selected bookmarks
#	Rename shape key set names (key blocks)

# Things marked with a * should be separate operators from the operator they are indented from.

# Utilities
#	MarkSharpByAutoSmooth (DONE)
#	MakePhysicsBones (TODO, unstable, can be improved)
#	CreateLightMapUVs (DONE)
#	ConvertImages (TODO, convert to operator)
#	ForceApplyMirrorModifier (TODO list inside, needs improvements for the mid-line)
#	UnfuckSFMArmature - Could add more SFM clean-up related stuff. Best wait for Red Eye to improve his mdl importer though.

# Consistency toolset
#	MakeModifiersConsistent (TODO, convert to operator)
#	CleanUpBlend
#		Done, could be put into separate operators:
#			*Remove unused vertex groups - TODO: consider shape key masks
#			Rename mesh datas
#			Rename Single UV Maps
#			Remove Blender Internal texture slots (May be reduntant in 2.8, and would probably throw errors)
#			Fix Material Names (ending in .001) - Might need some improvement.
#			Also try removing .001 from object names. (Probably check if an object without .001 exists, and if not, rename it)
#			Clear Unused Nodes
#			Hide node sockets: This thing is kindof useless imo and we should remove it.
#			Center Nodes
#			Fix Texture References
#		Additions:
#			Remove unused UV Maps(use code from Bioshock cleanup script)
#			Clear Shape Key and Vertex Group search bars on all objects.
#			Set Vertex Group value slider to 1.0 on all objects.
#			Open or close or leave as it is: all bone constraints
#			Open or close or leave as it is: all modifiers
#			*Delete unused groups
#			*Delete unused textures
#			*Delete unused materials
#			Relies on being able to enter edit mode on all objects(including hidden objects and objects on hidden layers):
#				Unhide and deselect all in edit mode on all objects
#				Seams from Islands
#				Weight Normals (Add to my script, credit original author)
#				Shade Smooth/Flat

# Global toggles
#	AutoSmooth On/Off
#	Autosmooth angle
#	UseAlpha
#	ClothCache
#	TextureNodesWidth

##########################################################

bl_info = {
	"name": "MetsTools",
	"author": "Met",
	"version": (2,2),
	"blender": (2, 79, 0),
	"location": "View3D > Space Menu I guess ",
	"description": "All kinds of trash",
	"category": "3D View"}
	
import bpy
import mathutils
import bmesh
import math
from bpy.props import IntProperty
from bpy.props import FloatProperty
from bpy.props import BoolProperty

class MakePhysicsBones(bpy.types.Operator):
	bl_idname = "pose.make_physics_bones"
	bl_label = "Make Physics Bones"
	bl_options = {'REGISTER', 'UNDO'}
	
	# Note: It will derp if the Armature has been scaled. :/ Will think about it. Perhaps scaling up the mesh by the same amount would work. No it wouldn't. We need to get world locations of the bone heads and I don't know how to. Could do with cursor but insanely finnicky.


	def execute(self, context):	
	# How it works:
		# Make a mesh that has a vertex at each bone (to later apply cloth physics to)
		# Make a vertexgroup for each vert
		# Extrude all verts - having faces is necessary for collision detection.
		# Put Cloth modifier on the mesh
		# Set the first vertex group as the Pin.
		# Set the collision group to a group named "Collision" if such exists.

		# Unparent selected bones
		# Make copy location and stretch to constraints pointing at the previously created mesh's vertex groups
		# And then it should work! Alt+A to find out!
		collisionGroup = "Collision"

		myArmature = bpy.context.object
		if(myArmature.scale != mathutils.Vector((1.0, 1.0, 1.0))):
			print( "ERROR: Armature scale needs to be applied(be careful when doing so and make a backup)" )
			return { "CANCELLED" }

		bones = bpy.context.selected_pose_bones
		parentBone = bones[0].parent

		# Create physics mesh (It gets automatically selected)
		bpy.ops.mesh.primitive_plane_add(enter_editmode=True, location=bones[0].head)
		bpy.context.object.name = "_Phys_" + bones[0].name

		physMesh = bpy.context.object
		physVerts = physMesh.data.vertices

		# We can't deselect a single vert without bmesh without knowing which edges and faces are connected to it
		# So I just deselect everything then select what I need.
		bpy.ops.mesh.select_all(action='DESELECT')
		bpy.ops.object.mode_set(mode='OBJECT')

		# Need to select verts while in object mode for some reason.
		for i in range(1,4):
			physVerts[i].select=True

		bpy.ops.object.mode_set(mode='EDIT')
		bpy.ops.mesh.delete(type='VERT')
		bpy.ops.object.mode_set(mode='OBJECT')

		# Setting the last remaining vert to the object's location(first bone's head)
		physVerts[0].select=True
		physVerts[0].co = (0, 0, 0)

		bpy.ops.object.mode_set(mode='EDIT')

		# Extruding verts to each bone's head
		for i in range(0, len(bones)):
			bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={"value":(
			bones[i].tail.x - bones[i].head.x, 
			bones[i].tail.y - bones[i].head.y, 
			bones[i].tail.z - bones[i].head.z)})

		bpy.ops.object.mode_set(mode='OBJECT')

		for i in range(0, len(physVerts)):
			bpy.ops.object.vertex_group_add()   			# Create new vertex group
			physMesh.vertex_groups[i].add([i], 1.0, 'ADD')  # Adding vert to vertex group (vertexIndex, Weight, 'garbage')
			if(i == 0):
				physMesh.vertex_groups[i].name = "Pin"
			else:
				physMesh.vertex_groups[i].name = bones[i-1].name # Naming vGroup
				
		# Extruding all verts to have faces, which is necessary for collision.
		bpy.ops.object.mode_set(mode='EDIT')
		bpy.ops.mesh.select_all(action='SELECT')
		bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={"value":(0, 0, 0)})
		bpy.ops.object.mode_set(mode='OBJECT')

		# Adding Cloth modifier
		bpy.ops.object.modifier_add(type='CLOTH')
		clothMod = physMesh.modifiers["Cloth"]
		clothMod.settings.use_pin_cloth=True
		clothMod.settings.vertex_group_mass = physMesh.vertex_groups[0].name
		if(bpy.data.groups.get(collisionGroup) is not None):
			clothMod.collision_settings.group = bpy.data.groups[collisionGroup]

		if(parentBone is not None):
			bpy.ops.object.mode_set(mode='OBJECT')  		# Go to object mode
			bpy.ops.object.select_all(action='DESELECT')	# Deselect everything
			physMesh.select = True  						# Select physics mesh
			myArmature.select = True						# Select armature
			bpy.context.view_layer.objects.active = myArmature   # Make armature active
			bpy.ops.object.mode_set(mode='POSE')			# Go into pose mode
			bpy.ops.pose.select_all(action='DESELECT')  	# Deselect everything
			parentBone.bone.select = True   				# Make parent bone select
			myArmature.data.bones.active = parentBone.bone  # Make the parent bone active
			bpy.ops.object.parent_set(type='BONE')  		# Set parent (=Ctrl+P->Bone)
			#bpy.ops.pose.select_all(action='SELECT')   # Not sure why this is here.
			parentBone.bone.select = False

		bpy.context.view_layer.objects.active = myArmature   # This should already be active.

		# Setting up bone constraints
		for i in range(0, len(bones)):
			bones[i].bone.select=True
			
			CL = bones[i].constraints.new(type='COPY_LOCATION')
			CL.target = physMesh
			CL.subtarget = physMesh.vertex_groups[i].name
			
			ST = bones[i].constraints.new(type='STRETCH_TO')
			ST.target = physMesh
			ST.subtarget = physMesh.vertex_groups[i+1].name

		bpy.ops.object.mode_set(mode='EDIT')
		bpy.ops.armature.separate() # Physics bones needs to be a separate armature to avoid dependency cycles.
		bpy.ops.object.mode_set(mode='POSE')
		return { 'FINISHED' }

def draw_func_MakePhysicsBones(self, context):
	self.layout.operator(MakePhysicsBones.bl_idname, text=MakePhysicsBones.bl_label)

class MarkSharpByAutoSmooth(bpy.types.Operator):
	bl_idname = "object.mark_sharp_by_auto_smooth"
	bl_label = "Bake Auto Smooth"
	bl_options = {'REGISTER', 'UNDO'}
	
	# What it does: "Bakes" the hard edges of all selected meshes that are caused by the Auto Smooth angle. Only works if auto smooth is turned on for the object.
	
	# How it works:
	#	Use bmesh to calculate the angle of each edge, then compare it to the auto smooth angle and if it's greater, it is un-marked as smooth. Aka marked sharp.
	
	def execute(self, context):
		orgActive = bpy.context.view_layer.objects.active
		orgMode = orgActive.mode

		for o in bpy.context.selected_objects:
			bpy.context.view_layer.objects.active = o
			if(o.data.use_auto_smooth == False):
				print(str(o.name) + "Auto smooth is off, not doing anything")
			else:
				bpy.ops.object.mode_set(mode='EDIT')
				bpy.ops.mesh.select_all(action='SELECT')
				bpy.ops.mesh.faces_shade_smooth()
				bpy.context.object.data.show_edge_sharp = True
				
				myBM = bmesh.from_edit_mesh(o.data)
				
				for e in myBM.edges:
					if( e.calc_face_angle(0) >= o.data.auto_smooth_angle ):
						e.smooth = False
						
				bpy.ops.object.mode_set(mode='OBJECT')

		bpy.context.view_layer.objects.active = orgActive
		bpy.ops.object.mode_set(mode=orgMode)
		
		return { 'FINISHED' }

def draw_func_MarkSharpByAutoSmooth(self, context):
	self.layout.operator(MarkSharpByAutoSmooth.bl_idname, text=MarkSharpByAutoSmooth.bl_label)

class CreateLightMapUVs(bpy.types.Operator):
	bl_idname = "object.create_lightmap_uvs"
	bl_label = "Create LightMap UVs"
	bl_options = {'REGISTER', 'UNDO'}
	
	# What it does: Creates Lightmap UVs using Smart UV Project on the second UV channel for UE4.

	# How it works:
	# For each selected object:
	#	Create new UV map (hopefully this will become selected by default)
	#	Rename it to UV_LightMap
	#	Make mesh active
	#	Go edit mode
	#	Select all
	#	Smart UV project with default values
	#	re-Select first UV map
	# Make original active object active again, as if nothing's happened.
	
	prop_AngleLimit: IntProperty(name="Angle Limit",
				default=66, min=1, max=89, soft_min=1, soft_max=89)
				
	prop_IslandMargin: FloatProperty(name="Island Margin",
				default=0.01, min=0, max=1, soft_min=0, soft_max=1)

	prop_OWExisting: BoolProperty(name="Overwrite Existing", default=True)
	prop_ResetSlot: BoolProperty(name="Preserve active UV slot", default=True)
	
	def execute(self, context):
		overwriteExisting = self.prop_OWExisting
		resetActiveUVSlot = self.prop_ResetSlot
		angleLimit = self.prop_AngleLimit
		islandMargin = self.prop_IslandMargin

		orgActiveObj = bpy.context.view_layer.objects.active
		orgMode = orgActiveObj.mode
		bpy.ops.object.mode_set(mode='OBJECT')

		for o in bpy.context.selected_objects:
			oldMode = o.mode
			bpy.context.view_layer.objects.active = o
			if(overwriteExisting):
				UVLayer = o.data.uv_textures.get("UV_LightMap")
				if(UVLayer is not None):
					UVLayer.active = True
					bpy.ops.mesh.uv_texture_remove()
			if(len(o.data.uv_layers) is 1):
			
				bpy.ops.object.mode_set(mode='EDIT')
				
				bpy.ops.mesh.uv_texture_add()
				o.data.uv_layers[-1].name = "UV_LightMap"
				bpy.ops.mesh.select_all(action='SELECT')
				bpy.ops.uv.smart_project(island_margin=islandMargin, angle_limit=angleLimit)
				if(resetActiveUVSlot):
					o.data.uv_textures[0].active = True
				
				bpy.ops.object.mode_set(mode=oldMode)

		bpy.context.view_layer.objects.active = orgActiveObj
		bpy.ops.object.mode_set(mode=orgMode)
		
		return { 'FINISHED' }
	
def draw_func_CreateLightMapUVs(self, context):
	self.layout.operator(CreateLightMapUVs.bl_idname, text=CreateLightMapUVs.bl_label)
	
class CleanUpBlend(bpy.types.Operator):
# General TODO
#	Should only affect objects in the active scene. Maybe add an option to affect every scene.
#	Should only affect materials that are used by selected objects, or objects in the active scene.
	bl_idname = "object.clean_up_blend"
	bl_label = "Clean Up Blend"
	bl_options = {'REGISTER', 'UNDO'}
	
	opt_freeze: BoolProperty(
		name="Freeze Operator", 
		default=False, 
		description="Freeze the operator to change settings without having to wait for the operator to run.")
	
	opt_renameData: BoolProperty(
		name="Rename Datas", 
		default=True, 
		description="If an object or armature is named 'Apple', its data will be renamed to 'Data_Apple'")
	
	opt_renameUVs: BoolProperty(
		name="Rename UV Maps", 
		default=True, 
		description="If an object has only one UVMap, rename that to the default: 'UVMap'.")
	
	opt_removeUnusedMats: BoolProperty(
		name="Remove Unused Materials", 
		default=True, 
		description="If a material has no faces assigned to it, it will be removed from the object. Objects with no faces are ignored.")
	
	opt_clearIntTex: BoolProperty(name="Clear BI Texture Slots", 
		default=False, 
		description="Clear all Blender Internal texture slots.")
		
	opt_fixMatNames: BoolProperty(name="Fix Material Names", 
		default=False, 
		description="Materials ending in .001 or similar will be attempted to be renamed.")
		
	opt_clearUnusedNodes: BoolProperty(name="Clear Unused Nodes", 
		default=False, 
		description="Clear all nodes (except Frames) in all materials that aren't linked to the 'Material Output' node.")
		
	opt_hideSockets: BoolProperty(name="Hide Node Sockets", 
		default=False, 
		description="Hide all unplugged sockets on nodes if they have more than Maximum Sockets number of unplugged sockets on either side. You can un-hide these with Ctrl+H in the Node Editor.")
		
	opt_minSockets: IntProperty(name="Maximum Sockets", 
		default=2, 
		description="See 'Hide Node Sockets'.")
		
	opt_centerNodes: BoolProperty(name="Center Nodes", 
		default=True, 
		description="Center all node setups including world and compositing nodes.")
		
	opt_fixTexRefs: BoolProperty(name="Fix Texture References", 
		default=False, 
		description="If a node references a texture called 'ABC.tga.001' but 'ABC.tga' exists, the reference will be replaced.")
		
	opt_renameTexNodes: BoolProperty(name="Rename Texture Nodes", 
		default=True, 
		description="Set the name and label of Image Texture Nodes to the name of the Texture they are referencing.")
		
	opt_cleanZeroWeights: BoolProperty(name="Clean Zero Weights", 
		default=True, 
		description="Clear all vertex weights that are 0.00.")

	opt_clearZeroVGroups: BoolProperty(name="Clear Empty Vertex Groups", 
		default=False, 
		description="Clear all vertex groups that have no weights at all. Shouldn't break mirror modifier as long as names end in 'R' and 'L'.")
		
	opt_clearUnusedVGroups: BoolProperty(name="Clear Unused Vertex Groups", 
		default=False, 
		description="Clear all vertex groups that aren't used by any modifiers and don't have any equivalent Bones in any Armature modifier of the object.")
		
	def getLinkedNodes(self, nodes, node):	# Recursive function to collect all nodes connected BEFORE the second parameter.
		nodes.append(node)
		for i in node.inputs:
			if(len(i.links) > 0):
				self.getLinkedNodes(nodes, i.links[0].from_node)
		return nodes
			
	def cleanNodeTree(self, nodes, outputNode=None):	# nodes = nodeTree.nodes
		if(self.opt_clearUnusedNodes and outputNode!=None):
			linkedNodes = self.getLinkedNodes([], outputNode)
			for n in nodes:
				# Deleting unconnected nodes
				if(n.type != 'FRAME'):	# TODO: should move frames that don't have any nodes in them.
					if(n not in linkedNodes):
						print("Removing unconnected node: Type: " + n.type + " Name: " + n.name + " Label: " + n.label)
						nodes.remove(n)
						continue
				
			# Changing .xxx texture references
			#print("Changing .xxx texture references...")
			if(self.opt_fixTexRefs):
				if(n.type == 'TEX_IMAGE'):
					if(n.image is not None and 
					n.image.name[-4] == '.' and
					bpy.data.images.get(n.image.name[:-4]) is not None):
						print("Changed texture reference: "+n.image.name)
						n.image = bpy.data.images.get(n.image.name[:-4])
						
			
			# Renaming image texture nodes
			#print("Renaming Image Texture nodes...")
			if(self.opt_renameTexNodes):
				if( (n.type == 'TEX_IMAGE') and (n.image is not None) ):
					old_name = n.name
					old_label = n.label
					extension = "." + n.image.name.split(".")[-1]
					n.name = n.image.name.replace(extension, "")
					n.label = n.name
					if(n.label[-4] == '.'):
						n.label = n.label[:-4]
					if(old_name != n.name):
						print("Renamed from: "+ old_name + " to: " + n.name)
					if(old_label != n.label):
						print("Relabelled from: "+ old_label + " to: " + n.label)
			
			# Hiding unplugged sockets
			if(self.opt_hideSockets):
				unplugged = []
				for i in n.inputs:
					if(len(i.links) == 0):
						unplugged.append(i)
				if(len(unplugged) > self.opt_minSockets):
					for u in unplugged:
						u.hide = True
				
				for i in n.outputs:
					if(len(i.links) == 0):
						unplugged.append(i)
				if(len(unplugged) > self.opt_minSockets):
					for u in unplugged:
						u.hide = True
		
		if(self.opt_centerNodes):
			#Average location of all nodes is a pretty bad way to try to center the node set-up
			#xAvg = sum(nod.location.x for nod in nodes)/len(nodes)
			#yAvg = sum(nod.location.y for nod in nodes)/len(nodes)
			
			# Finding bounding box values
			xMin = min(n.location.x for n in nodes)
			xMax = max(n.location.x for n in nodes)
			yMin = min(n.location.y for n in nodes)
			yMax = max(n.location.y for n in nodes)
			
			# Finding bounding box center
			xMid = (xMin+xMax)/2
			yMid = (yMin+yMax)/2
			
			# Moving all nodes by the amount of the bounding box center(therefore making the center 0,0) - except Frame nodes, which move by themselves.
			for n in nodes:
				if(n.type != 'FRAME'):
					n.location.x -= xMid
					n.location.y -= yMid

	def execute(self, context):
		cleanNodeTree = self.cleanNodeTree
		getLinkedNodes = self.getLinkedNodes
	
		opt_freeze				= self.opt_freeze
		if(opt_freeze):
			return {'FINISHED'}
		opt_renameData 			= self.opt_renameData
		opt_renameUVs 			= self.opt_renameUVs
		opt_removeUnusedMats 	= self.opt_removeUnusedMats
		opt_clearIntTex 		= self.opt_clearIntTex
		opt_fixMatNames 		= self.opt_fixMatNames
		opt_clearUnusedNodes 	= self.opt_clearUnusedNodes
		opt_hideSockets			= self.opt_hideSockets
		opt_minSockets			= self.opt_minSockets
		opt_centerNodes			= self.opt_centerNodes
		opt_fixTexRefs 			= self.opt_fixTexRefs
		opt_renameTexNodes		= self.opt_renameTexNodes

		opt_cleanZeroWeights	= self.opt_cleanZeroWeights
		opt_clearZeroVGroups	= self.opt_clearZeroVGroups
		opt_clearUnusedVGroups	= self.opt_clearUnusedVGroups
		
		
		activeObj = bpy.context.view_layer.objects.active
		################### PER OBJECT STUFF ###################
		objs = bpy.context.selected_objects
		for o in objs:
			if(o.type == 'MESH' or o.type == 'ARMATURE'):
				print("...Working on object: "+o.name)
				bpy.ops.object.mode_set(mode="OBJECT")
				bpy.context.view_layer.objects.active = o
				
				# Naming mesh/skeleton data blocks
				if(opt_renameData):
					o.data.name = "Data_" + o.name
					
				# That's it for armatures. (for now?)
				if(o.type == 'ARMATURE'):
					continue
				
				# Cleaning useless weights (using built-in Clean operator)
				if(opt_cleanZeroWeights):
					if(len(o.vertex_groups) > 0):
						bpy.ops.object.vertex_group_clean(group_select_mode='ALL', limit=0)
				
				safeVGroups = []
				# Saving vertex groups that are used by modifiers and therefore should not be removed TODO: this could obviously be done better. Just make a list of vertex attribute names that can have vertex groups and loop through them. Also add particle system stuff, and double-check that we have every physics stuff.
				for m in o.modifiers:
					if(hasattr(m, 'vertex_group_a')):
						if(m.vertex_group_a is not '' and o.vertex_groups.get(m.vertex_group_a) is not None):
							safeVGroups.append(o.vertex_groups[m.vertex_group_a])
					if(hasattr(m, 'vertex_group_b')):
						if(m.vertex_group_b is not '' and o.vertex_groups.get(m.vertex_group_b) is not None):
							safeVGroups.append(o.vertex_groups[m.vertex_group_b])
					if(hasattr(m, 'mask_vertex_group')):
						if(m.mask_vertex_group is not '' and o.vertex_groups.get(m.mask_vertex_group) is not None):
							safeVGroups.append(o.vertex_groups[m.mask_vertex_group])
					if(hasattr(m, 'vertex_group')):
						if(m.vertex_group is not '' and o.vertex_groups.get(m.vertex_group) is not None):
							safeVGroups.append(o.vertex_groups[m.vertex_group])
					if(hasattr(m, 'settings')):	#Physics modifiers
						if(hasattr(m.settings, 'vertex_group_mass')):
							if(m.settings.vertex_group_mass is not '' and o.vertex_groups.get(m.settings.vertex_group_mass) is not None):
								safeVGroups.append(o.vertex_groups[m.settings.vertex_group_mass])
						if(hasattr(m.settings, 'vertex_group_structural_stiffness')):
							if(m.settings.vertex_group_structural_stiffness is not '' and o.vertex_groups.get(m.settings.vertex_group_structural_stiffness) is not None):
								safeVGroups.append(o.vertex_groups[m.settings.vertex_group_structural_stiffness])
						if(hasattr(m.settings, 'vertex_group_bending')):
							if(m.settings.vertex_group_bending is not '' and o.vertex_groups.get(m.settings.vertex_group_bending) is not None):
								safeVGroups.append(o.vertex_groups[m.settings.vertex_group_bending])
						if(hasattr(m.settings, 'vertex_group_shrink')):
							if(m.settings.vertex_group_shrink is not '' and o.vertex_groups.get(m.settings.vertex_group_shrink) is not None):
								safeVGroups.append(o.vertex_groups[m.settings.vertex_group_shrink])
						if(hasattr(m.settings, 'vertex_group_goal')):
							if(m.settings.vertex_group_goal is not '' and o.vertex_groups.get(m.settings.vertex_group_goal) is not None):
								safeVGroups.append(o.vertex_groups[m.settings.vertex_group_goal])
						if(hasattr(m.settings, 'vertex_group_spring')):
							if(m.settings.vertex_group_spring is not '' and o.vertex_groups.get(m.settings.vertex_group_spring) is not None):
								safeVGroups.append(o.vertex_groups[m.settings.vertex_group_spring])
				# Getting a list of relevant bones for later, from the first assigned armature.
				bones = 0
				for m in o.modifiers:
					if(m.type == 'ARMATURE'):
						myArm = m.object
						if myArm is None:
							continue
						if(bones is 0):
							bones = list(map(lambda x: x.name, myArm.pose.bones))
						else:
							bones.extend(list(map(lambda x: x.name, myArm.pose.bones)))
							#print("bones: "+str(bones))
				
				for v in reversed(o.vertex_groups):					# For each vertex group
					
					#print("......Clearing vertex groups with no bones...")
					# Clearing vertex groups that don't have a corresponding bone in the first assigned armature.
					if(opt_clearUnusedVGroups):
						if( bones is not 0 and (v.name not in bones) and (v not in safeVGroups) ):
							print("Unused vgroup removed: "+v.name)
							o.vertex_groups.remove(v)
							continue
					
					# Saving vertex groups that have any weights assigned to them, also considering mirror modifiers (needs to end in 'R' or 'L'
					for i in range(0, len(o.data.vertices)):	# For each vertex
						try:
							v.weight(i)							# If there's a weight assigned to this vert (Else exception)
							if(v not in safeVGroups):
								safeVGroups.append(v)
								
								#The below few lines are fucking cancer please don't hurt me I don't want to regex
								oppSide = 'L' if ( ('.R' in v.name) or (("_R" in v.name) or (v.name.endswith("R"))) ) else 'R'	# Don't know where to put parentheses therefore I put parentheses everywhere!
								thisSide = 'L' if oppSide is 'R' else 'R'
								
								oppGroup = o.vertex_groups.get( v.name.replace("."+thisSide, "."+oppSide))
								if( oppGroup is None ):
									oppGroup = o.vertex_groups.get( v.name.replace("_"+thisSide, "_"+oppSide))
									if ( oppGroup is None ):
										oppGroup = o.vertex_groups.get( v.name[:-1] + ('L' if v.name.endswith('R') else 'R')) 	# If you write bad code, at least make it unreadable!

								# If the above beautiful code got us something other than None, add it to the list, else do nothing.
								safeVGroups.append(oppGroup) if oppGroup is not None else True
								break
						except RuntimeError:					# Otherwise it will throw this exception and 	we do nothing.
							continue
				
				#print("......Clearing vertex groups with no weights...")
				# Clearing vertex groups that have no weights at all
				if(opt_clearZeroVGroups):
					for v in o.vertex_groups:
						if(v not in safeVGroups):
							print("Empty vgroup removed: "+v.name)
							o.vertex_groups.remove(v)
				
				# Naming UV map if there is only one
				if(opt_renameUVs):
					if(len(o.data.uv_layers) == 1):
						o.data.uv_layers[0].name = "UVMap"
				
				# Removing materials that have no faces applied
				#print("......Removing materials that have no faces applied...")
				if(opt_removeUnusedMats):
					usedMats = []
					if( len(o.data.polygons) == 0 ):
						continue
					for f in o.data.polygons:
						if(f.material_index not in usedMats):
							usedMats.append(f.material_index)
					for i in range(len(o.material_slots)-1, -1, -1):	# In the range of length-1 to -1 with an increment of -1. (Iterating in reverse using index. Reverse because we are removing elements while iterating.)
						if(i not in usedMats):
							o.active_material_index = i
							print("Removed material slot " + str(i))
							bpy.ops.object.material_slot_remove()

		################## PER MATERIAL STUFF ##################			
		mats = bpy.data.materials
		# TODO: Make it affect selection only.
		
		for m in mats:
			print("......Working on Material: "+m.name)
			
			# Clearing Blender Internal textures
			if(opt_clearIntTex):
				if(bpy.context.scene.render.engine == 'CYCLES'):
					for ts in m.texture_slots:
						if(ts is not None):
							print("Removed BI texture " + ts.name)
							ts.texture = None
			
			# Clearing .00x from end of names
			if(opt_fixMatNames):
				if(('.' in m.name) and (m.name[-4] == '.')):
					print("...Cleared .00x from end of Material name.")
					m.name = m.name[:-4]
			
			### NODE STUFF ###
			
			# Cleaning nodetree
			if(m.use_nodes):
				myNodes = m.node_tree.nodes
				
				# Cleaning references to nodegroups ending in .001
				# TODO: Add an option for this I guess.
				for n in myNodes:
					if(n.type=='GROUP'):
						if('.00' in n.node_tree.name):
							non_dupe = bpy.data.node_groups.get(n.node_tree.name[:-4])
							if(non_dupe):
								n.node_tree = non_dupe
				
				outputNode = list(filter(lambda x: x.type == 'OUTPUT_MATERIAL', myNodes))[0]
				cleanNodeTree(myNodes, outputNode)

		for w in bpy.data.worlds:	# Cleaning up World nodes
			if(w.use_nodes):
				myNodes = w.node_tree.nodes
				outNode = list(filter(lambda x: x.type == 'OUTPUT_WORLD', myNodes))[0]
				cleanNodeTree(myNodes, outNode)

		for s in bpy.data.scenes:	# Cleaning up compositing nodes
			if(s.use_nodes):
				myNodes = s.node_tree.nodes
				outNode = list(filter(lambda x: x.type == 'COMPOSITE', myNodes))[0]
				cleanNodeTree(myNodes, outNode)
		
		for nt in bpy.data.node_groups:
			cleanNodeTree(myNodes, outNode)
			
			
		bpy.context.view_layer.objects.active = activeObj
		return {'FINISHED'}

def register():
	from bpy.utils import register_class
	register_class(CleanUpBlend)
	register_class(CreateLightMapUVs)
	register_class(MarkSharpByAutoSmooth)
	register_class(MakePhysicsBones)
	
	#bpy.types.MESH_MT_shape_key_specials.append(draw_func_ApplyShapeKeyAsBase)
	bpy.types.VIEW3D_MT_pose_specials.append(draw_func_MakePhysicsBones)
	bpy.types.VIEW3D_MT_edit_mesh.append(draw_func_MarkSharpByAutoSmooth)
	bpy.types.VIEW3D_MT_uv_map.append(draw_func_CreateLightMapUVs)

def unregister():
	from bpy.utils import unregister_class
	unregister_class(CleanUpBlend)
	unregister_class(CreateLightMapUVs)
	unregister_class(MarkSharpByAutoSmooth)
	unregister_class(MakePhysicsBones)
	
	#bpy.types.MESH_MT_shape_key_specials.remove(draw_func_ApplyShapeKeyAsBase)
	bpy.types.VIEW3D_MT_pose_specials.remove(draw_func_MakePhysicsBones)
	bpy.types.VIEW3D_MT_edit_mesh.remove(draw_func_MarkSharpByAutoSmooth)
	bpy.types.VIEW3D_MT_uv_map.remove(draw_func_CreateLightMapUVs)

register()